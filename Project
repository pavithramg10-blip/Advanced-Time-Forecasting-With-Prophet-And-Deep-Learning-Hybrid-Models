import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from prophet import Prophet
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error, mean_absolute_error
from math import sqrt

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

np.random.seed(42)
N = 600

time = np.arange(N)
trend = 0.05 * time
seasonality = 10 * np.sin(2 * np.pi * time / 30)
regime_shift = np.where(time > 350, 30, 0)
noise = np.random.normal(0, 3, N)

y = 100 + trend + seasonality + regime_shift + noise

df = pd.DataFrame({
    "ds": pd.date_range("2018-01-01", periods=N),
    "y": y,
    "temp": np.random.normal(25, 3, N),
    "holiday_index": np.random.randint(0, 2, N)
})

train = df.iloc[:-60]
test = df.iloc[-60:]

sarima_model = SARIMAX(train["y"], order=(3,1,2), seasonal_order=(1,1,1,30))
sarima_fit = sarima_model.fit(disp=False)


sarima_forecast = sarima_fit.forecast(60)

prophet_df = train[["ds", "y", "temp", "holiday_index"]]

model_prophet = Prophet()
model_prophet.add_regressor("temp")
model_prophet.add_regressor("holiday_index")
model_prophet.fit(prophet_df)

future = model_prophet.make_future_dataframe(periods=60)
future["temp"] = df["temp"]
future["holiday_index"] = df["holiday_index"]

prophet_forecast = model_prophet.predict(future).iloc[-60:]["yhat"].values

def create_sequences(series, seq_len=30):
    X, y = [], []
    for i in range(len(series) - seq_len):
        X.append(series[i:i+seq_len])
        y.append(series[i+seq_len])
    return np.array(X), np.array(y)

seq_len = 30
series = train["y"].values
X_train, y_train = create_sequences(series, seq_len)
X_train = X_train.reshape((X_train.shape[0], seq_len, 1))

lstm_model = Sequential([
    LSTM(64, activation="tanh", return_sequences=True),
    LSTM(32, activation="tanh"),
    Dense(1)
])

lstm_model.compile(optimizer="adam", loss="mse")
lstm_model.fit(X_train, y_train, epochs=10, batch_size=32, verbose=0)

test_series = df["y"].values[-(60+seq_len):]
X_test = np.array([test_series[i:i+seq_len] for i in range(60)])
X_test = X_test.reshape((60, seq_len, 1))

lstm_forecast = lstm_model.predict(X_test).flatten()

prophet_train_pred = model_prophet.predict(prophet_df)["yhat"].values
residuals = train["y"].values - prophet_train_pred

X_res, y_res = create_sequences(residuals, seq_len)
X_res = X_res.reshape((X_res.shape[0], seq_len, 1))

hybrid_lstm = Sequential([
    LSTM(64, return_sequences=True),
    LSTM(32),
    Dense(1)
])
hybrid_lstm.compile(optimizer="adam", loss="mse")
hybrid_lstm.fit(X_res, y_res, epochs=10, batch_size=32, verbose=0)

res_series_test = np.concatenate([residuals[-seq_len:], np.zeros(60)])
X_res_test = np.array([res_series_test[i:i+seq_len] for i in range(60)])
X_res_test = X_res_test.reshape((60, seq_len, 1))

residual_forecast = hybrid_lstm.predict(X_res_test).flatten()
hybrid_forecast = prophet_forecast + residual_forecast

true = test["y"].values

def metrics(pred):
    return {
        "RMSE": sqrt(mean_squared_error(true, pred)),
        "MAE": mean_absolute_error(true, pred),
        "MAPE": np.mean(np.abs((true - pred) / true)) * 100
    }

results = {
    "SARIMA": metrics(sarima_forecast),
    "Prophet": metrics(prophet_forecast),
    "LSTM": metrics(lstm_forecast),
    "Hybrid": metrics(hybrid_forecast)
}

print("\n=== MODEL PERFORMANCE ===")
for model, score in results.items():
    print(f"\n{model}:")
    for metric, value in score.items():
        print(f"  {metric}: {value:.4f}")

plt.figure(figsize=(12,6))
plt.plot(test["ds"], true, label="True", linewidth=3)
plt.plot(test["ds"], sarima_forecast, label="SARIMA")
plt.plot(test["ds"], prophet_forecast, label="Prophet")
plt.plot(test["ds"], lstm_forecast, label="LSTM")
plt.plot(test["ds"], hybrid_forecast, label="Hybrid", linewidth=3)
plt.legend()
plt.grid()
plt.title("Forecast Comparison")
plt.show()
